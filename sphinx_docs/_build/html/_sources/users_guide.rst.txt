Users Guide
***********

Introduction
============

Diva is a python library for creating interactive web analytics dashboards. Let's start with an example:

.. literalinclude:: ../examples/minimal_example.py

`See the result of our example here. <https://fizznow.com>`_

First, we create a ``Diva`` object. Next, we use python's `decorator syntax <https://realpython.com/blog/python/primer-on-python-decorators/>`_ to register our analytics functions ``foo`` and ``bar`` with our ``Diva`` object. The ``view`` decorator *does not modify the underlying function* (``view`` just stores a reference to it in the ``Diva`` object). You can call ``foo`` or ``bar`` elsewhere in your code as if you weren't using ``diva`` at all. Finally, we call ``app.run()``, which serves the website linked above. The site contains a report for every function we register with our ``Diva`` object.

You can pass a list of widgets to ``view``. The ``bar`` function takes an integer and a float, so we pass the ``Int`` and ``Float`` objects to ``view``. As you can see, the webserver generates HTML widgets corresponding to these python objects. When we reload the ``bar`` report, the values of these widgets are sent to the server. Their values are passed to ``bar``, and the result of ``bar`` is sent back to the browser (converted to HTML).

API
====

.. function:: Diva()
    
The constructor for Diva takes no arguments.

.. function:: Diva.view(name, *widgets)
    
``name`` is what the view will be called in the web interface. ``widgets`` is a (possibly empty) list of diva.widgets.Widget objects. Please see the Widgets section for a list of available widgets and what values they pass to the underlying function. Intuitively, the value of the value of the nth widget in ``*widgets`` is passed to the nth argument of the underlying function.

Consider::
    
    @app.view('example report', Int('choose an int'), Float('choose a float'))
    def bar(a, b):
        ...

Suppose you choose values of 2 and 3.5 for the widgets then reload the report. Internally, ``bar`` will be called like ``bar(a=2, b=3.5)``. To keep things simple, just make the number of widgets the same as the number of function arguments. If your function takes ``*args``, ``**kwargs``, specifies defaults, or is otherwise complex, you may need to suffer the following mild inconvenience::

    def bar(a, b, *args, **kwargs):
        ...

    @app.view('example report',
        Int('choose an int'),
        Float('choose a float'),
        String('choose a string'),
        Bool('choose a bool'))
    def bar_shim(my_int, my_float, my_str, my_bool):
        # in bar: a=my_int, b=my_float, args=(my_str), kwargs={'baz': my_bool}
        return bar(my_int, my_float, my_str, baz=my_bool) 

.. function:: Diva.run(host=None, port=None, debug=None, **options)

TODO refer to the documentation for Flask.

Widgets
========

The built-in widgets (available from ``from diva.widgets import *``) are:

* String
* Float
* Int
* Bool
* SelectOne
* SelectSubset
* Color
* Slider (for float or int)
* Date
* DateRange
* Time

You can see each widget in action `here <https://fizznow.com>`_. The first argument passed to every widget constructor is the description of the widget in the web interface (such as, "choose a scale"). 

**String**

**Float**

**Int**

**Bool**

**SelectOne**

**SelectSubset**

**Color**

**Slider**

**Date**

**DateRange**

**Time**

Security
=========

TODO: reminder about Flask security. Also about input sanitation.

Add your own converters
========================

Add your own widgets
=====================
